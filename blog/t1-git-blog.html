<!DOCTYPE html>
<head>
  <title>heycait's Technical Blog</title>
  <meta charset="UTF-8">
  <link rel="stylesheet" type="text/css" href="your-stylesheet-link-here.css">
</head>

<main>

  <h1>Technical Blog</h1>
  <h2> Phase 0: Unit 1, Week 1</h2>
  <h4>Bootdate 201502.06 (aka 06 Feb 2015)</h4>

  <section>
    <p>
      Now that I’ve completed week 1 (minus the bonus challenges which I’ll get to after this), it’s time to get down and dirty with a more serious and in-depth review post.
    </p>

    <p>
      In essence, P0.U1.W1 has been about prepping and understanding what the command line, git, and GitHub are and how to use them. Mixed into that were instructions to set everything up on your computer; learning about time management and productivity and how those can be incorporated into your life and hopefully make your Phase 0 experience a little more manageable; and creating your developer’s online presence.
    </p>

    <p>
      The first challenge was researching time management/productivity and was more of a personal development kind of lesson. It seems to be a preview of what’s to come during the on-site engineering empathy courses as it goes over mediation and really relates to Chade-meng Tan’s ‘Search Inside Yourself’ book.
    </p>

    <p>
      Learning the command line was next. This is a SUPER IMPORTANT lesson I learned the hard way. Before starting Phase 0 and back when I was learning Ruby on my own, I realized I had many problems and I didn’t know what they were or what questions I needed to ask to get them answered. In my more convoluted and tongue-twister way of saying it, <b>I didn’t know what I didn’t know and I didn’t know what to ask so I didn’t know how to find out</b>. This challenge is central to learning how to code as nearly everything you do is done from the command line! To those of you out there learning on your own, I recommend going through a command line tutorial first BEFORE doing anything else. It’ll most likely provide you the answer to questions you’d ask if you didn’t do it first. Trust me.
    </p>

     <p>
      The next several challenges were around git and GitHub, what they are, how to use them etc. I’m only going to say three things about that here. First, when reading the “Get Started Working with Git” article, make use of the links to learning tools provided at the bottom. The <a href="https://try.github.io/levels/1/challenges/1">Try Git</a>
      tutorial is a wonderful overview of how to use git and a great preview of the following challenges. My only advice here is to just go over it once to get a general idea. You’ll get down to the nitty gritty later on so don’t get all flustered trying to squeeze into your brain everything little thing. It won’t stick until you actually use the commands on your own in later challenges. Second, if you really want to understand what forking is check out this stack overflow question
      <a href="http://stackoverflow.com/questions/3611256/forking-vs-branching-in-github">StackOverflow question</a>. DBC’s current curriculum doesn’t actually explain what it is just how to do it. The responses there are a good explanation of what it is and how it differs from branches/branching.  Third, I wanted to share my analogy of the 3 stages of git. It's not a perfect analogy as there may be some gaps in the metaphor but I think it's still pretty decent. Ideally, this would be best if I could accompany my explanation with a video but as I’m a horrible artist and an inexperience videographer, the analogy below will have to suffice.
    </p>
    <p>
      The 3 steps of git are just like the process of editing a book. Let’s set the stage first.
    </p>

    <p>
      You’ve got a long table with a giant calendar pad in front of you. Except it isn’t a calendar pad but an imaginary rectangular area on your desk where you do all your work—reading, writing, typing, etc—this desk space is what's known as the ‘working directory’ in programming world. Behind the calendar-desk-pad-sized-rectangular-area are 3 file bins: the ‘Needs Editing’ bin, the ‘Edited’ bin, and the ‘Outgoing’ bin, or in other words, initializing git tracking, staging, and committing, respectively.
    </p>

    <p>
      Once a book is placed into the ‘Needs Editing’, aka the initialize git stage [using: $git init], you’ve begun the process of tracking those changes. You grab the book and move it from the ‘Needs Editing’ bin to your desk space—the working directory—and begin editing. You read over the book once, making changes as you go along. Once you’ve completed all the changes, you move the book from your working desk space to the ‘Edited’ bin—the stage—[using: $git add file_name] where you either set it aside for later and work on another book or jump back into a second look of it. Immediately following or after editing another book and moving the second book to the 'Edited' bin, you go back and quickly look over the first book a second time by flipping through it while it’s still in the bin. After going though it a second time and confirming those are your final revisions, you move it from the ‘Edited’ bin to the ‘Outgoing’ bin—the ‘HEAD’—[using: $git commit -m “note of changes made”] with a sticky note of the changes you made. You’re not done just yet though. The author hasn’t seen your edits, therefore you push the book from your ‘Outgoing’ bin onto the author’s desk right next to yours and have him/her look through them [using: git push name_of_remote_repo name_of_your_repo]. If they agree to the changes, they incorporate them into the final copy of the book and voila! You’ve just completed the editing process for a book and learned about the stages of git at the same time!
    </p>

    <p>
      <b>NOTE:</b> Pushing changes yourself and submitting a pull request is the same process up to when you push the changes. After that, a pull request is an extended process where another person goes through a similar editing process on your revisions and is the final person to decide on those changes and whether to push it to the final/master version or not.
    </p>

    <p>
      And finally, more as a note to self, here's a description and cheat sheet for what bash is, how to change the profile, and how to change the path.
    </p>

    <p> <a href="http://linuxcommand.org/lts0010.php"><b>The Shell</b></a>
      "Simply put, the shell is a program that takes your commands from the keyboard and gives them to the operating system to perform. In the old days, it was the only user interface available on a Unix computer. Nowadays, we have graphical user interfaces (GUIs) in addition to command line interfaces (CLIs) such as the shell.

      On most Linux systems a program called bash (which stands for Bourne Again SHell, an enhanced version of the original Bourne shell program, sh, written by Steve Bourne) acts as the shell program. There are several additional shell programs available on a typical Linux system. These include: ksh, tcsh and zsh."
    </p>

    <p> <a href="http://www.linuxfromscratch.org/blfs/view/6.3/postlfs/profile.html"><b>Bash</b></a>
      "The shell program /bin/bash (hereafter referred to as just "the shell") uses a collection of startup files to help create an environment. Each file has a specific use and may affect login and interactive environments differently." [Note there are many different types of shell programs of which bash is one]
    </p>

    <p> <a href="http://stackoverflow.com/questions/25949636/why-use-path-and-what-is-it"><b>Bash</b></a>
      "The path is the search path for commands. It is a colon-separated list of directories in which the shell looks for commands (see COMMAND EXECUTION below). A zero-length (null) directory name in the value of PATH indicates the current directory. A null directory name may appear as two adjacent colons, or as an initial or trailing colon. The default path is system-dependent, and is set by the administrator who installs bash. A common value is /usr/gnu/bin:/usr/local/bin:/usr/ucb:/bin:/usr/bin' "
    </p>

    <p><b> Cheat Sheet:</b></p>
    <p>
      echo $SHELL #check default shell
    </p>

    <p>
      ls -a #list all files including hidden ones
    </p>

    <p>
       export PATH=/path/to/location:$PATH   OR    export PATH=$PATH:/new_path_entry  #use to change path and restart terminal to take effect
    </p>

    <p>
      echo PATH $check the path and ensure it changed
    </p>

  </section>

  <h2> Sublime, Git, & GitHub Reflection</h2>
  <h4>02 Feb 15</h4>

  <section>
    <p>
      These reflections sure are getting repetitive. But I guess that’s good as now the answers just come spewing out. The one downside though is it also makes me question myself. The questions are pretty much restated in different ways but sometimes it makes me feel like I’m still missing something, like in the last challenge where it asked “How does tracking and adding changes make a developer’s lives easier?”. Is this just basically asking about version control and it’s uses and benefits or is there some thing else I’m not seeing here that “makes a dev’s life easier"?
    </p>
    <p>
        Anyways, it’s time to get serious and answer these questions.
    </p>
    <p>
        1. What are the benefits of version control?
    </p>
    <p>

        2. How does git help you keep track of changes?
    </p>
    <p>
        3. Why use GitHub to store you code?
    </p>

    <p>
      The benefits of version control is that you can view every change made to a file/project. It’s a history or a log of everything that’s happened from the start to the present. This is important because it allows you to check the progress and see how the project evolved as well as go back to an old version if the present one has too many problems, was accidentally deleted, or runs into some other setback. It also provides information as to who did what and when which allows you to reference that person and their work later on if needed.
    </p>

    <p>
      There are many different types of version control systems and Git is one of them. Git is the system that does all the tracking and storing of the different versions. It also provides other features at the same time. For example, when working on a part of a file that you want to edit, you don’t have to do that right on the file itself but in a copy of it. The benefit of this is that you don’t have to mess with the original file until you know for sure what you’ve been working on is functional. Once you know your additions are viable, you can add your changes back into the original. This function of editing a copy and adding it back to the original is known as branching and merging.
    </p>

    <p>
      While Git is a version control system, it is only a local system meaning it only tracks and stores information on the computer it’s on. GitHub, on the other hand, is an online hub that stores Gits from individuals, hence the name GitHub. It acts as a connection for individuals to store their Gits (or their log of changes), access others’ files and make changes, and basically is a central tool for collaborating on a project. In a way, it’s like your Git cloud that anyone anywhere can access if you give them that privilege and it’ll track and store all changes in real-time.
    </p>
      <!-- copy and paste as many sections as you want to add paragraphs -->
  </section>
</main>